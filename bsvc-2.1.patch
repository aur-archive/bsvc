diff -ur bsvc-2.1/src/Assemblers/68kasm/codegen.c bsvc-2.1-fixed/src/Assemblers/68kasm/codegen.c
--- bsvc-2.1/src/Assemblers/68kasm/codegen.c	1998-11-09 04:39:28.000000000 +0100
+++ bsvc-2.1-fixed/src/Assemblers/68kasm/codegen.c	2007-05-30 22:47:40.000000000 +0200
@@ -70,7 +70,7 @@
 		case BYTE : printf("Output: Byte           %02X put into output stream at location %08X\n", data, loc); break;
 		case WORD : printf("Output: Word         %04X put into output stream at location %08X\n", data, loc); break;
 		case LONG : printf("Output: Longword %08X put into output stream at location %08X\n", data, loc); break;
-		default   : printf("OUTPUT: INVALID SIZE CODE!\n"); exit();
+		default   : printf("OUTPUT: INVALID SIZE CODE!\n"); exit(1);
 		}  */
 	if (listFlag)
 		listObj(data, size);
@@ -168,6 +168,6 @@
 					loc += 4;
 					}
 				  break;
-		default		: printf("INVALID EFFECTIVE ADDRESSING MODE!\n"); exit();
+		default		: printf("INVALID EFFECTIVE ADDRESSING MODE!\n"); exit(1);
 		}
 }
diff -ur bsvc-2.1/src/Assemblers/68kasm/listing.c bsvc-2.1-fixed/src/Assemblers/68kasm/listing.c
--- bsvc-2.1/src/Assemblers/68kasm/listing.c	1998-11-09 04:39:28.000000000 +0100
+++ bsvc-2.1-fixed/src/Assemblers/68kasm/listing.c	2007-05-30 22:47:40.000000000 +0200
@@ -81,7 +81,7 @@
 	listFile = fopen(name, "w");
 	if (!listFile) {	
 		puts("Can't open listing file");
-		exit();
+		exit(1);
 		}
 }
 
@@ -96,7 +96,7 @@
 		putc('\n', listFile);
 	if (ferror(listFile)) {
 		fputs("Error writing to listing file\n", stderr);
-		exit();
+		exit(1);
 		}
 }
 
@@ -131,6 +131,6 @@
 		case LONG : sprintf(listPtr, "%08X ", data);
 			    listPtr += 9;
 			    break;
-		default   : printf("LISTOBJ: INVALID SIZE CODE!\n"); exit();
+		default   : printf("LISTOBJ: INVALID SIZE CODE!\n"); exit(1);
 		}
 }
diff -ur bsvc-2.1/src/Assemblers/68kasm/main.c bsvc-2.1-fixed/src/Assemblers/68kasm/main.c
--- bsvc-2.1/src/Assemblers/68kasm/main.c	1998-11-09 04:39:28.000000000 +0100
+++ bsvc-2.1-fixed/src/Assemblers/68kasm/main.c	2007-05-30 22:47:40.000000000 +0200
@@ -71,7 +71,7 @@
 	if (!inFile)
 	{
  		fputs("Couldn't create temporary file\n", stderr);
-		exit();
+		exit(1);
 	}
           
 	strcpy(fileName, argv[i]);
@@ -79,13 +79,13 @@
         
 	if (!srcFile) {
 		fputs("Input file not found\n", stderr);
-		exit();
+		exit(1);
 		}
 
 	error = buildCompleteSourceFile(srcFile, fileName, inFile, 1);
 	if (error) {
 		fputs(error, stderr);
-		exit();
+		exit(1);
 	} 
        
         /* Rewind the in file to the beginning */ 
@@ -302,6 +302,6 @@
 	puts("         -l  Produce listing file (infile.lis)");
 	puts("         -n  Produce NO object file (infile.h68)");
 	puts("         -a  Produce long word absolute addresses only (infile.h68)");
-	exit();
+	exit(1);
 }
 
diff -ur bsvc-2.1/src/Assemblers/68kasm/object.c bsvc-2.1-fixed/src/Assemblers/68kasm/object.c
--- bsvc-2.1/src/Assemblers/68kasm/object.c	1998-11-09 04:39:28.000000000 +0100
+++ bsvc-2.1-fixed/src/Assemblers/68kasm/object.c	2007-05-30 22:47:40.000000000 +0200
@@ -78,7 +78,7 @@
 	objFile = fopen(name, "w");
 	if (!objFile) {	
 		puts("Can't open object file");
-		exit();
+		exit(1);
 		}
 	/* Output S-record file header */
 /*	fputs("Here comes an S-record...\n", objFile); */
@@ -133,7 +133,7 @@
 			    byteCount += 4;
 			    checksum += checkValue(data);
 			    break;
-		default   : printf("outputObj: INVALID SIZE CODE!\n"); exit();
+		default   : printf("outputObj: INVALID SIZE CODE!\n"); exit(1);
 		}
 	objPtr += size*2;
 	objAddr += size;
@@ -165,7 +165,7 @@
 	fputs(sRecord, objFile);
 	if (ferror(objFile)) {
 		fputs(objErrorMsg, stderr);
-		exit();
+		exit(1);
 		}
 }
 
@@ -180,7 +180,7 @@
 	fputs("S9030000FC\n", objFile);
 	if (ferror(objFile)) {
 		fputs(objErrorMsg, stderr);
-		exit();
+		exit(1);
 		}
 	fclose(objFile);
 }	
diff -ur bsvc-2.1/src/Framework/AddressSpace.hxx bsvc-2.1-fixed/src/Framework/AddressSpace.hxx
--- bsvc-2.1/src/Framework/AddressSpace.hxx	1998-11-09 04:39:28.000000000 +0100
+++ bsvc-2.1-fixed/src/Framework/AddressSpace.hxx	2007-05-30 22:47:40.000000000 +0200
@@ -26,9 +26,7 @@
 #include <list>
 #include <string>
 
-#ifdef USE_STD
-  using namespace std;
-#endif
+using namespace std;
 
 class AddressSpace;
 class BasicDevice;
diff -ur bsvc-2.1/src/Framework/BasicDevice.hxx bsvc-2.1-fixed/src/Framework/BasicDevice.hxx
--- bsvc-2.1/src/Framework/BasicDevice.hxx	1998-11-09 04:39:28.000000000 +0100
+++ bsvc-2.1-fixed/src/Framework/BasicDevice.hxx	2007-05-30 22:47:40.000000000 +0200
@@ -20,11 +20,9 @@
 #ifndef BASICDEVICE_HXX
 #define BASICDEVICE_HXX
 
-#include <string>
+#include <cstring>
 
-#ifdef USE_STD
-  using namespace std;
-#endif
+using namespace std;
 
 class BasicDevice;
 class BasicCPU;
diff -ur bsvc-2.1/src/Framework/BasicDeviceRegistry.hxx bsvc-2.1-fixed/src/Framework/BasicDeviceRegistry.hxx
--- bsvc-2.1/src/Framework/BasicDeviceRegistry.hxx	1998-11-09 04:39:28.000000000 +0100
+++ bsvc-2.1-fixed/src/Framework/BasicDeviceRegistry.hxx	2007-05-30 22:47:40.000000000 +0200
@@ -20,9 +20,7 @@
 
 #include <string>
 
-#ifdef USE_STD
-  using namespace std;
-#endif
+using namespace std;
 
 class BasicCPU;
 class BasicDevice;
diff -ur bsvc-2.1/src/Framework/BreakpointList.hxx bsvc-2.1-fixed/src/Framework/BreakpointList.hxx
--- bsvc-2.1/src/Framework/BreakpointList.hxx	1998-11-09 04:39:28.000000000 +0100
+++ bsvc-2.1-fixed/src/Framework/BreakpointList.hxx	2007-05-30 22:47:40.000000000 +0200
@@ -19,9 +19,7 @@
 
 #include <set>
 
-#ifdef USE_STD
-  using namespace std;
-#endif
+using namespace std;
 
 class BreakpointList {
   private:
diff -ur bsvc-2.1/src/Framework/Interface.cxx bsvc-2.1-fixed/src/Framework/Interface.cxx
--- bsvc-2.1/src/Framework/Interface.cxx	1998-11-09 04:39:28.000000000 +0100
+++ bsvc-2.1-fixed/src/Framework/Interface.cxx	2007-05-30 22:47:40.000000000 +0200
@@ -31,14 +31,12 @@
   #include <sys/types.h>
   #include <unistd.h>
 
-  #include <iostream.h>
-  #include <strstream.h>
+  #include <iostream>
+  #include <strstream>
   #include <string>
 #endif
 
-#ifdef USE_STD
-  using namespace std;
-#endif
+using namespace std;
 
 #include "Interface.hxx"
 #include "BasicCPU.hxx"
diff -ur bsvc-2.1/src/Framework/Interface.hxx bsvc-2.1-fixed/src/Framework/Interface.hxx
--- bsvc-2.1/src/Framework/Interface.hxx	1998-11-09 04:39:28.000000000 +0100
+++ bsvc-2.1-fixed/src/Framework/Interface.hxx	2007-05-30 22:47:40.000000000 +0200
@@ -18,15 +18,9 @@
 #ifndef INTERFACE_HXX
 #define INTERFACE_HXX
 
-#ifdef WIN32
-  #include <iostream>
-#else
-  #include <iostream.h>
-#endif
+#include <iostream>
 
-#ifdef USE_STD
-  using namespace std;
-#endif
+using namespace std;
 
 class BasicCPU;
 class BasicDeviceRegistry;
diff -ur bsvc-2.1/src/Framework/Tools.hxx bsvc-2.1-fixed/src/Framework/Tools.hxx
--- bsvc-2.1/src/Framework/Tools.hxx	1998-11-09 04:39:28.000000000 +0100
+++ bsvc-2.1-fixed/src/Framework/Tools.hxx	2007-05-30 22:47:40.000000000 +0200
@@ -19,9 +19,7 @@
 
 #include <string>
 
-#ifdef USE_STD
-  using namespace std;
-#endif
+using namespace std;
 
 ///////////////////////////////////////////////////////////////////////////////
 // Convert the hex string to an unsigned integer
diff -ur bsvc-2.1/src/Makefile.common bsvc-2.1-fixed/src/Makefile.common
--- bsvc-2.1/src/Makefile.common	1998-11-09 04:39:28.000000000 +0100
+++ bsvc-2.1-fixed/src/Makefile.common	2007-05-30 22:48:16.000000000 +0200
@@ -12,7 +12,7 @@
 ###############################################################################
 
 ## Base Directory of the BSVC distribution
-PROJECT_BASE = /home/bwmott/projects/bsvc/development/bsvc
+PROJECT_BASE = /usr/src/bsvc/src/bsvc-2.1
 
 ## Directory to install the BSVC system
 INSTALL_DIR = $(PROJECT_BASE)/bin
diff -ur bsvc-2.1/src/Tools/xtermpipe/xtermpipe.cxx bsvc-2.1-fixed/src/Tools/xtermpipe/xtermpipe.cxx
--- bsvc-2.1/src/Tools/xtermpipe/xtermpipe.cxx	1998-11-09 04:39:28.000000000 +0100
+++ bsvc-2.1-fixed/src/Tools/xtermpipe/xtermpipe.cxx	2007-05-30 22:47:40.000000000 +0200
@@ -14,6 +14,8 @@
 #include <stdio.h>
 #include <signal.h>
 
+using namespace std;
+
 int WaitForIO(int pipe_id)
 {
   fd_set readfds;
@@ -31,7 +33,7 @@
     select(pipe_id + 1, (int*)&readfds, (int*)&writefds, (int*)&exceptfds,
            (void*)0);
 # else
-    select(pipe_id + 1, &readfds, &writefds, &exceptfds, (void*)0);
+    select(pipe_id + 1, &readfds, &writefds, &exceptfds, (timeval*)0);
 # endif
 
   if(FD_ISSET(0, &readfds))
@@ -40,7 +42,7 @@
     return(1);
 }
 
-main()
+int main()
 {
   int read_id, write_id;
 
diff -ur bsvc-2.1/src/sim68000/cpu/Makefile bsvc-2.1-fixed/src/sim68000/cpu/Makefile
--- bsvc-2.1/src/sim68000/cpu/Makefile	1998-11-09 04:39:28.000000000 +0100
+++ bsvc-2.1-fixed/src/sim68000/cpu/Makefile	2007-05-30 22:47:40.000000000 +0200
@@ -28,7 +28,7 @@
 	$(CC) $(INCLUDES) -o instruction instruction.c
 
 m68000DecodeTable.hxx: instruction instruction.list
-	$(PROJECT_BASE)/src/sim68000/cpu/instruction  
+	./instruction  
 
 clean:
 	rm -f *.o $(LIBRARY) instruction
diff -ur bsvc-2.1/src/sim68000/cpu/exec.cxx bsvc-2.1-fixed/src/sim68000/cpu/exec.cxx
--- bsvc-2.1/src/sim68000/cpu/exec.cxx	1998-11-09 04:39:28.000000000 +0100
+++ bsvc-2.1-fixed/src/sim68000/cpu/exec.cxx	2007-05-30 22:47:40.000000000 +0200
@@ -15,13 +15,11 @@
 
 #include <string>
 
-#ifdef USE_STD
-  using namespace std;
-#endif
+using namespace std;
 
-#include "AddressSpace.hxx"
+#include "../../Framework/AddressSpace.hxx"
 #include "m68000.hxx"
-#include "Tools.hxx"
+#include "../../Framework/Tools.hxx"
 
 ///////////////////////////////////////////////////////////////////////////////
 // Compute the effective address, given the mode and register bits
diff -ur bsvc-2.1/src/sim68000/cpu/m68000.cxx bsvc-2.1-fixed/src/sim68000/cpu/m68000.cxx
--- bsvc-2.1/src/sim68000/cpu/m68000.cxx	1998-11-09 04:39:28.000000000 +0100
+++ bsvc-2.1-fixed/src/sim68000/cpu/m68000.cxx	2007-05-30 22:47:40.000000000 +0200
@@ -13,11 +13,11 @@
 // $Id: m68000.cxx,v 1.1 1996/08/02 14:59:18 bwmott Exp $
 ///////////////////////////////////////////////////////////////////////////////
 
-#include "Tools.hxx"
+#include "../../Framework/Tools.hxx"
 #include "m68000.hxx"
-#include "BasicDevice.hxx"
-#include "RegInfo.hxx"
-#include "AddressSpace.hxx"
+#include "../../Framework/BasicDevice.hxx"
+#include "../../Framework/RegInfo.hxx"
+#include "../../Framework/AddressSpace.hxx"
 
 // Array of information about each register
 m68000::RegisterData m68000::ourRegisterData[] = {
diff -ur bsvc-2.1/src/sim68000/cpu/m68000.hxx bsvc-2.1-fixed/src/sim68000/cpu/m68000.hxx
--- bsvc-2.1/src/sim68000/cpu/m68000.hxx	1998-11-09 04:39:28.000000000 +0100
+++ bsvc-2.1-fixed/src/sim68000/cpu/m68000.hxx	2007-05-30 22:47:40.000000000 +0200
@@ -18,19 +18,13 @@
 
 #include <string>
 
-#ifdef WIN32
-  #include <iostream>
-#else
-  #include <iostream.h>
-#endif
+#include <iostream>
 
-#ifdef USE_STD
-  using namespace std;
-#endif
+using namespace std;
 
 class BasicDevice;
 
-#include "BasicCPU.hxx"
+#include "../../Framework/BasicCPU.hxx"
 
 // Instruction Size Constants
 #define BYTE   0
diff -ur bsvc-2.1/src/sim68000/devices/DeviceRegistry.hxx bsvc-2.1-fixed/src/sim68000/devices/DeviceRegistry.hxx
--- bsvc-2.1/src/sim68000/devices/DeviceRegistry.hxx	1998-11-09 04:39:28.000000000 +0100
+++ bsvc-2.1-fixed/src/sim68000/devices/DeviceRegistry.hxx	2007-05-30 22:47:40.000000000 +0200
@@ -17,7 +17,7 @@
 #ifndef DEVICEREGISTRY_HXX
 #define DEVICEREGISTRY_HXX
 
-#include "BasicDeviceRegistry.hxx"
+#include "../../Framework/BasicDeviceRegistry.hxx"
 
 ///////////////////////////////////////////////////////////////////////////////
 // The DeviceRegistry Class
diff -ur bsvc-2.1/src/sim68000/devices/M68681.cxx bsvc-2.1-fixed/src/sim68000/devices/M68681.cxx
--- bsvc-2.1/src/sim68000/devices/M68681.cxx	1998-11-09 04:39:28.000000000 +0100
+++ bsvc-2.1-fixed/src/sim68000/devices/M68681.cxx	2007-05-30 22:47:40.000000000 +0200
@@ -13,8 +13,8 @@
 // $Id: M68681.cxx,v 1.1 1996/08/02 15:01:10 bwmott Exp $
 ///////////////////////////////////////////////////////////////////////////////
 
-#include <iostream.h>
-#include <strstream.h>
+#include <iostream>
+#include <strstream>
 #include <string>
 
 #include <sys/types.h>
@@ -22,7 +22,7 @@
 #include <fcntl.h>
 #include <signal.h>
 
-#include "BasicCPU.hxx"
+#include "../../Framework/BasicCPU.hxx"
 #include "M68681.hxx"
 
 // Callback types
diff -ur bsvc-2.1/src/sim68000/devices/M68681.hxx bsvc-2.1-fixed/src/sim68000/devices/M68681.hxx
--- bsvc-2.1/src/sim68000/devices/M68681.hxx	1998-11-09 04:39:28.000000000 +0100
+++ bsvc-2.1-fixed/src/sim68000/devices/M68681.hxx	2007-05-30 22:47:40.000000000 +0200
@@ -19,7 +19,9 @@
 #include <string>
 #include <sys/types.h>
 
-#include "BasicDevice.hxx"
+using namespace std;
+
+#include "../../Framework/BasicDevice.hxx"
 
 class M68681 : public BasicDevice {
   public:
diff -ur bsvc-2.1/src/sim68000/devices/RAM.cxx bsvc-2.1-fixed/src/sim68000/devices/RAM.cxx
--- bsvc-2.1/src/sim68000/devices/RAM.cxx	1998-11-09 04:39:28.000000000 +0100
+++ bsvc-2.1-fixed/src/sim68000/devices/RAM.cxx	2007-05-30 22:47:40.000000000 +0200
@@ -13,20 +13,13 @@
 // $Id: RAM.cxx,v 1.1 1996/08/02 15:02:49 bwmott Exp $
 ///////////////////////////////////////////////////////////////////////////////
 
-#ifdef WIN32
-  #include <iostream>
-  #include <strstream>
-#else
-  #include <iostream.h>
-  #include <strstream.h>
-#endif
-
-#ifdef USE_STD
-  using namespace std;
-#endif
+#include <iostream>
+#include <strstream>
 
-#include "Tools.hxx"
-#include "BasicCPU.hxx"
+using namespace std;
+
+#include "../../Framework/Tools.hxx"
+#include "../../Framework/BasicCPU.hxx"
 #include "RAM.hxx"
 
 ///////////////////////////////////////////////////////////////////////////////
diff -ur bsvc-2.1/src/sim68000/devices/RAM.hxx bsvc-2.1-fixed/src/sim68000/devices/RAM.hxx
--- bsvc-2.1/src/sim68000/devices/RAM.hxx	1998-11-09 04:39:28.000000000 +0100
+++ bsvc-2.1-fixed/src/sim68000/devices/RAM.hxx	2007-05-30 22:47:40.000000000 +0200
@@ -18,11 +18,9 @@
 
 #include <string>
 
-#ifdef USE_STD
-  using namespace std;
-#endif
+using namespace std;
 
-#include "BasicDevice.hxx"
+#include "../../Framework/BasicDevice.hxx"
 
 class RAM : public BasicDevice {
   public:
diff -ur bsvc-2.1/src/sim68000/devices/Timer.cxx bsvc-2.1-fixed/src/sim68000/devices/Timer.cxx
--- bsvc-2.1/src/sim68000/devices/Timer.cxx	1998-11-09 04:39:28.000000000 +0100
+++ bsvc-2.1-fixed/src/sim68000/devices/Timer.cxx	2007-05-30 22:47:40.000000000 +0200
@@ -1,366 +1,358 @@
-///////////////////////////////////////////////////////////////////////////////
-//
-// Timer.cxx
-//
-//   This class keeps up with a list of all of the availible devices and
-// allocates them.  It's dervied from the BasicDeviceRegistry
-//
-// FILENAME: Timer.cxx
-// DESC: Simulates an timer for the M68000 CPU. Thus giving 
-//       the Simulator the ablility to simulate a timmer intrurpt.
-//       Programmers can impliment time slicing with this timmer.
-//
-//       Contains Register and Offsets for the timer. 
-//
-// CREATE:  7-17-98
-// OWNER:   Xavier Plasencia
-// ORG:	    SDSU
-// DEPEN:   This file requiers the Event hander and the BasicDevice files.  
-//
-///////////////////////////////////////////////////////////////////////////////
-// $Id: $
-///////////////////////////////////////////////////////////////////////////////
-
-#ifdef WIN32
-  #include <iostream>
-  #include <strstream>
-  #include <cstring>
-#else
-  #include <iostream.h>
-  #include <strstream.h>
-  #include <string.h>
-#endif
-
-#ifdef USE_STD
-  using namespace std;
-#endif
-
-#include "BasicCPU.hxx"
-#include "Timer.hxx"
-
-///////////////////////////////////////////////////////////////////////////////
-// Constructor
-///////////////////////////////////////////////////////////////////////////////
-Timer::Timer(const string& args, BasicCPU& cpu)
-	: BasicDevice("Timer", args, cpu)
-{
-  istrstream in((char*)args.data(), args.size());
-  string keyword, equals;
-  unsigned long base;
-  unsigned long irq;
-
-  firstTime = true;
-  // Scan "BaseAddress = nnnn"
-  // This is important for the CPU to know what address space
-  // is used by the device.
-  in >> keyword >> equals >> hex >> base;
-  if((!in) || (keyword != "BaseAddress") || (equals != "="))
-  {
-     ErrorMessage("Invalid initialization arguments!");
-     return;
-  }
-
-  in >> keyword >> equals >> hex >> irq;
-  if((!in) || (keyword != "IRQ") || (equals != "="))
-  {
-     ErrorMessage("Invalid initialization arguments!");
-     return;
-  }
-
-/*
-  I've hardcoded the cycles setting to 2000 which should provide the
-  125000 ticks per second for the PI/T
-
-  unsigned long timer_cycle;
-  in >> keyword >> equals >> hex >> timer_cycle;
-  if((!in) || (keyword != "CycleSec") || (equals != "="))
-  {
-     ErrorMessage("Invalid initialization arguments!");
-     return;
-  }
-  Timer::TIMER_CPU_CYCLE = timer_cycle;
-*/
-
-  Timer::TIMER_IRQ = irq;
-  Timer::TIMER_CPU_CYCLE = 2000;
-  baseAddress = base * cpu.Granularity();
-
-  // This is needed to start the whole process.  The eventhandler
-  // will always request an event and test to see if the user has
-  // enabled the timer it not nothing happens but if so. The
-  // CPR  register is copied to the CNTR and is decremented for every
-  // Cycle.
-  (myCPU.eventHandler()).Add(this, TIMER_EVENT, 0, TIMER_CPU_CYCLE);
-
-  Reset(); 
-}
-
-///////////////////////////////////////////////////////////////////////////////
-// This routine should set myInterruptPending flag and send a request
-// to the CPU for an interrupt.
-///////////////////////////////////////////////////////////////////////////////
-void Timer::InterruptRequest(int level)
-{
-  // If no interrupt is pending then request one
-  if(!myInterruptPending)
-  {
-    myInterruptPending = true;
-    myCPU.InterruptRequest(this, level);
-  }
-}
-       
-/*___________________________________________________________________________
- | FUNCTIONAME: InterruptAcknowledge(int)
- | DESC: This routine is called by the CPU when it processes a 
- |  requested interrupt. It should return the vector number associated with 
- |  the interrupt or AUTOVECTOR_INTERRUPT if the device doesn't generate 
- |	vectors.  This default routine only does autovector interrupts.
- | 	This function is called by the CPU.  The return value is usally the
- | 	memory location of a exemption funcion.  How to handel these functions
- |	one shold refer to a Motorla text book.
- | PARAM: None
- | NOTE: Vecotor codes 5 and 7 are the only masks that will make the timer 
- | do somthing.  5 is a VECTOR and 7 is an AUTOVECTOR.  The code
- | can be found in any manual.
- |___________________________________________________________________________
-*/
-long Timer::InterruptAcknowledge(int)
-{
-  unsigned char cTCR = timerValue[TCR];
-
-  if(myInterruptPending)
-  {
-    switch(cTCR>>5)
-    {
-      case 5:
-        //By returning the address of the vector, the cpu will
-        //call the vector that is located in the right mem location.
-        myInterruptPending = false;
-        return timerValue[TIVR];
-        break; 
-
-      case 7:
-        myInterruptPending = false;
-        return AUTOVECTOR_INTERRUPT;
-        break;
-
-      default:
-        return SPURIOUS_INTERRUPT;
-    }
-  }
-  else
-  {
-    return(SPURIOUS_INTERRUPT);
-  }
-}
-
-/*______________________________________________________________
- | METHOD: Timer::CheckMapped( unsigned long adress)
- | DESC: Check to see if address mapps to device. 
- |______________________________________________________________
-*/
-bool Timer::CheckMapped(unsigned long address) const
-{
-  return ((address >= baseAddress ) && 
-      (address <= baseAddress+(22*sizeof(char))));
-}
-
-/*______________________________________________________________
- | METHOD: Timer::Peek(unsigned long address)
- | DESC:  Returns a byte from the device's address.
- |
- |	PEEK is the protocal that is used by the device to 
- |	inform the CPU what the registry settings are.
- |  The use need not update the memory location for the CPU
- |	All of this is done by the cpu and thus uses peek to
- |	read the data that the device is using for the  Memory
- |  (i.e. RAM)
- |______________________________________________________________
-*/
-unsigned char Timer::Peek(unsigned long address)
-{
-  switch((address-baseAddress))
-  {
-    case TCR:
-      return timerValue[TCR];
-    case TIVR:
-      return timerValue[TIVR];
-    case NULR:
-      return timerValue[NULR];
-    case CPRH:
-      return timerValue[CPRH];
-    case CPRM:
-      return timerValue[CPRM];
-    case CPRL:
-      return timerValue[CPRL];
-    case CNTRH:
-      return timerValue[CNTRH];
-    case CNTRM:
-      return timerValue[CNTRM];
-    case CNTRL:
-      return timerValue[CNTRL];
-    case TSR:
-      return timerValue[TSR];
-   }
-   return 0; //Error not a valid address.
-}
-
-/*______________________________________________________________
- | METHOD: Timer::Poke(unsigned long address, char c)
- | DESC:  This is the interface to the rest of the World.  Here
- |	the CPU or anyother devece writes to memory and updates the
- |  device.  Poke Changes the value of the registers.  
- |  Notice that there is no way for the user to WRITE to the 
- |  registers CNTR, this is because they are read only.
- |______________________________________________________________
-*/
-void Timer::Poke(unsigned long address, unsigned char c)
-{
-  switch((address-baseAddress))
-  {
-    case TCR:
-      timerValue[TCR]=c;
-      break;
-    case TIVR:
-      timerValue[TIVR]=c;
-      break;
-    case NULR:
-      timerValue[NULR]=c;
-      break;
-    case CPRH:
-      timerValue[CPRH]=c;
-      break;
-    case CPRM:
-      timerValue[CPRM]=c;
-      break;
-    case CPRL:
-      timerValue[CPRL]=c;
-      break;
-    case TSR:
-      timerValue[TSR]=c;
-      break;
-  }
-}
-
-/*______________________________________________________________
- | METHOD:  Timer::Reset()
- | DESC:	Resets the timer. And Initalizes the Registers.
- |______________________________________________________________
-*/
-void Timer::Reset()
-{
-  // Resets the interupt handler.
-  myInterruptPending = false;
-  firstTime = true;
-
-  // Clears the timers.
-  for(int i=0; i <22; i++)
-    timerValue[i]=0;
-}
-
-/*______________________________________________________________
- | METHOD:	VetcorTimer::EventCallback(long *data, void *ptr)
- | DESC:	Function that executes when interupt occures.
- | DEP FUNC: Requires decCNTR copyCPRtoCNTR.
- |______________________________________________________________
-*/
-void Timer::EventCallback(long data, void *ptr)
-{
-  unsigned char cTCR = timerValue[TCR];
-
-  // Test to see if timer is enabled, if False(0) do nothing.
-  // but dispatch an event.
-  if((cTCR&1) == 1)
-  {
-    // This test to see if the timer has not started a 
-    // count down.  If it hasnt, copy the CPR register vaules
-    // to the CNTR registers.
-    if(firstTime == true)
-    {
-      firstTime = false;
-      copyCPRtoCNTR();
-    }
-
-    // Decriments the CNTR if 0 then call interrupt.
-    // else dispatch an event.
-    if(decCNTR() != 0)
-    {
-      (myCPU.eventHandler()).Add(this, TIMER_EVENT, 0, TIMER_CPU_CYCLE);
-      return;
-    }
-
-    // Since the timer is now done, set the first time to ture,
-    // so the next time the TCR is set to 1 it will copy the
-    // CPR Register to CNTR.
-    firstTime = true;
-
-    // Protocal says that the TCR should flip to 0. and that
-    // TSR bit switches to 1. That is done below.
-    timerValue[TCR] = (timerValue[TCR] & 0xfe);
-    timerValue[TSR] = (timerValue[TSR] | 0x01);
-
-    // Dispatch an IRQ only if user has set this in the
-    // TCR register. (5 and 7) are the only valid
-    // Interupts.
-    if (((cTCR>>5) & 5) || ((cTCR>>5) &7))
-    {
-      InterruptRequest(TIMER_IRQ);
-    }
-    (myCPU.eventHandler()).Add(this, TIMER_EVENT, 0, TIMER_CPU_CYCLE);
-  }
-  else
-  {
-    (myCPU.eventHandler()).Add(this, TIMER_EVENT, 0, TIMER_CPU_CYCLE);
-  }
-}
-
-/*______________________________________________________________
- | METHOD:  CopyCPRtoCNTR
- | DESC:	Copies the register value of CPR to CNTR.
- | USED:	By funce  EventCallback
- | DEP FUNC: None
- |______________________________________________________________
-*/
-void Timer::copyCPRtoCNTR()
-{
-  timerValue[CNTRH] = timerValue[CPRH];
-  timerValue[CNTRM] = timerValue[CPRM];
-  timerValue[CNTRL] = timerValue[CPRL];
-}
-
-/*______________________________________________________________
- | METHOD: decCNTR
- | DESC: decriments the counter and checks for CNTR==0
- |		retuns the value of CNTR.
- |______________________________________________________________
-*/
-unsigned int Timer::decCNTR()
-{
-  int decValue;
-  int temp24;
-
-  // Grab the values of the 24bit register to a value.
-  decValue = 0;
-  temp24 = (unsigned int) timerValue[CNTRH];
-  decValue = (decValue | ( temp24 <<  24));
-
-  temp24 = (unsigned int) timerValue[CNTRM];
-  decValue = (decValue | (temp24 << 16));
-
-  decValue = (decValue | timerValue[CNTRL]);
-
-  decValue -= 250;
-  if(decValue < 0)
-  {
-    decValue = 0;
-  }
-
-  // Put the value  back  the 24bit register to a value.
-  // with the decremnt.
-  timerValue[CNTRH] = ( unsigned char) (decValue >>  24);
-  timerValue[CNTRM] = ( unsigned char) (decValue >> 16);
-  timerValue[CNTRL] = ( unsigned char) (decValue );
-
-  return (unsigned int) decValue;
-}
-
+///////////////////////////////////////////////////////////////////////////////
+//
+// Timer.cxx
+//
+//   This class keeps up with a list of all of the availible devices and
+// allocates them.  It's dervied from the BasicDeviceRegistry
+//
+// FILENAME: Timer.cxx
+// DESC: Simulates an timer for the M68000 CPU. Thus giving 
+//       the Simulator the ablility to simulate a timmer intrurpt.
+//       Programmers can impliment time slicing with this timmer.
+//
+//       Contains Register and Offsets for the timer. 
+//
+// CREATE:  7-17-98
+// OWNER:   Xavier Plasencia
+// ORG:	    SDSU
+// DEPEN:   This file requiers the Event hander and the BasicDevice files.  
+//
+///////////////////////////////////////////////////////////////////////////////
+// $Id: $
+///////////////////////////////////////////////////////////////////////////////
+
+#include <iostream>
+#include <strstream>
+#include <string>
+
+using namespace std;
+
+#include "../../Framework/BasicCPU.hxx"
+#include "Timer.hxx"
+
+///////////////////////////////////////////////////////////////////////////////
+// Constructor
+///////////////////////////////////////////////////////////////////////////////
+Timer::Timer(const string& args, BasicCPU& cpu)
+	: BasicDevice("Timer", args, cpu)
+{
+  istrstream in((char*)args.data(), args.size());
+  string keyword, equals;
+  unsigned long base;
+  unsigned long irq;
+
+  firstTime = true;
+  // Scan "BaseAddress = nnnn"
+  // This is important for the CPU to know what address space
+  // is used by the device.
+  in >> keyword >> equals >> hex >> base;
+  if((!in) || (keyword != "BaseAddress") || (equals != "="))
+  {
+     ErrorMessage("Invalid initialization arguments!");
+     return;
+  }
+
+  in >> keyword >> equals >> hex >> irq;
+  if((!in) || (keyword != "IRQ") || (equals != "="))
+  {
+     ErrorMessage("Invalid initialization arguments!");
+     return;
+  }
+
+/*
+  I've hardcoded the cycles setting to 2000 which should provide the
+  125000 ticks per second for the PI/T
+
+  unsigned long timer_cycle;
+  in >> keyword >> equals >> hex >> timer_cycle;
+  if((!in) || (keyword != "CycleSec") || (equals != "="))
+  {
+     ErrorMessage("Invalid initialization arguments!");
+     return;
+  }
+  Timer::TIMER_CPU_CYCLE = timer_cycle;
+*/
+
+  Timer::TIMER_IRQ = irq;
+  Timer::TIMER_CPU_CYCLE = 2000;
+  baseAddress = base * cpu.Granularity();
+
+  // This is needed to start the whole process.  The eventhandler
+  // will always request an event and test to see if the user has
+  // enabled the timer it not nothing happens but if so. The
+  // CPR  register is copied to the CNTR and is decremented for every
+  // Cycle.
+  (myCPU.eventHandler()).Add(this, TIMER_EVENT, 0, TIMER_CPU_CYCLE);
+
+  Reset(); 
+}
+
+///////////////////////////////////////////////////////////////////////////////
+// This routine should set myInterruptPending flag and send a request
+// to the CPU for an interrupt.
+///////////////////////////////////////////////////////////////////////////////
+void Timer::InterruptRequest(int level)
+{
+  // If no interrupt is pending then request one
+  if(!myInterruptPending)
+  {
+    myInterruptPending = true;
+    myCPU.InterruptRequest(this, level);
+  }
+}
+       
+/*___________________________________________________________________________
+ | FUNCTIONAME: InterruptAcknowledge(int)
+ | DESC: This routine is called by the CPU when it processes a 
+ |  requested interrupt. It should return the vector number associated with 
+ |  the interrupt or AUTOVECTOR_INTERRUPT if the device doesn't generate 
+ |	vectors.  This default routine only does autovector interrupts.
+ | 	This function is called by the CPU.  The return value is usally the
+ | 	memory location of a exemption funcion.  How to handel these functions
+ |	one shold refer to a Motorla text book.
+ | PARAM: None
+ | NOTE: Vecotor codes 5 and 7 are the only masks that will make the timer 
+ | do somthing.  5 is a VECTOR and 7 is an AUTOVECTOR.  The code
+ | can be found in any manual.
+ |___________________________________________________________________________
+*/
+long Timer::InterruptAcknowledge(int)
+{
+  unsigned char cTCR = timerValue[TCR];
+
+  if(myInterruptPending)
+  {
+    switch(cTCR>>5)
+    {
+      case 5:
+        //By returning the address of the vector, the cpu will
+        //call the vector that is located in the right mem location.
+        myInterruptPending = false;
+        return timerValue[TIVR];
+        break; 
+
+      case 7:
+        myInterruptPending = false;
+        return AUTOVECTOR_INTERRUPT;
+        break;
+
+      default:
+        return SPURIOUS_INTERRUPT;
+    }
+  }
+  else
+  {
+    return(SPURIOUS_INTERRUPT);
+  }
+}
+
+/*______________________________________________________________
+ | METHOD: Timer::CheckMapped( unsigned long adress)
+ | DESC: Check to see if address mapps to device. 
+ |______________________________________________________________
+*/
+bool Timer::CheckMapped(unsigned long address) const
+{
+  return ((address >= baseAddress ) && 
+      (address <= baseAddress+(22*sizeof(char))));
+}
+
+/*______________________________________________________________
+ | METHOD: Timer::Peek(unsigned long address)
+ | DESC:  Returns a byte from the device's address.
+ |
+ |	PEEK is the protocal that is used by the device to 
+ |	inform the CPU what the registry settings are.
+ |  The use need not update the memory location for the CPU
+ |	All of this is done by the cpu and thus uses peek to
+ |	read the data that the device is using for the  Memory
+ |  (i.e. RAM)
+ |______________________________________________________________
+*/
+unsigned char Timer::Peek(unsigned long address)
+{
+  switch((address-baseAddress))
+  {
+    case TCR:
+      return timerValue[TCR];
+    case TIVR:
+      return timerValue[TIVR];
+    case NULR:
+      return timerValue[NULR];
+    case CPRH:
+      return timerValue[CPRH];
+    case CPRM:
+      return timerValue[CPRM];
+    case CPRL:
+      return timerValue[CPRL];
+    case CNTRH:
+      return timerValue[CNTRH];
+    case CNTRM:
+      return timerValue[CNTRM];
+    case CNTRL:
+      return timerValue[CNTRL];
+    case TSR:
+      return timerValue[TSR];
+   }
+   return 0; //Error not a valid address.
+}
+
+/*______________________________________________________________
+ | METHOD: Timer::Poke(unsigned long address, char c)
+ | DESC:  This is the interface to the rest of the World.  Here
+ |	the CPU or anyother devece writes to memory and updates the
+ |  device.  Poke Changes the value of the registers.  
+ |  Notice that there is no way for the user to WRITE to the 
+ |  registers CNTR, this is because they are read only.
+ |______________________________________________________________
+*/
+void Timer::Poke(unsigned long address, unsigned char c)
+{
+  switch((address-baseAddress))
+  {
+    case TCR:
+      timerValue[TCR]=c;
+      break;
+    case TIVR:
+      timerValue[TIVR]=c;
+      break;
+    case NULR:
+      timerValue[NULR]=c;
+      break;
+    case CPRH:
+      timerValue[CPRH]=c;
+      break;
+    case CPRM:
+      timerValue[CPRM]=c;
+      break;
+    case CPRL:
+      timerValue[CPRL]=c;
+      break;
+    case TSR:
+      timerValue[TSR]=c;
+      break;
+  }
+}
+
+/*______________________________________________________________
+ | METHOD:  Timer::Reset()
+ | DESC:	Resets the timer. And Initalizes the Registers.
+ |______________________________________________________________
+*/
+void Timer::Reset()
+{
+  // Resets the interupt handler.
+  myInterruptPending = false;
+  firstTime = true;
+
+  // Clears the timers.
+  for(int i=0; i <22; i++)
+    timerValue[i]=0;
+}
+
+/*______________________________________________________________
+ | METHOD:	VetcorTimer::EventCallback(long *data, void *ptr)
+ | DESC:	Function that executes when interupt occures.
+ | DEP FUNC: Requires decCNTR copyCPRtoCNTR.
+ |______________________________________________________________
+*/
+void Timer::EventCallback(long data, void *ptr)
+{
+  unsigned char cTCR = timerValue[TCR];
+
+  // Test to see if timer is enabled, if False(0) do nothing.
+  // but dispatch an event.
+  if((cTCR&1) == 1)
+  {
+    // This test to see if the timer has not started a 
+    // count down.  If it hasnt, copy the CPR register vaules
+    // to the CNTR registers.
+    if(firstTime == true)
+    {
+      firstTime = false;
+      copyCPRtoCNTR();
+    }
+
+    // Decriments the CNTR if 0 then call interrupt.
+    // else dispatch an event.
+    if(decCNTR() != 0)
+    {
+      (myCPU.eventHandler()).Add(this, TIMER_EVENT, 0, TIMER_CPU_CYCLE);
+      return;
+    }
+
+    // Since the timer is now done, set the first time to ture,
+    // so the next time the TCR is set to 1 it will copy the
+    // CPR Register to CNTR.
+    firstTime = true;
+
+    // Protocal says that the TCR should flip to 0. and that
+    // TSR bit switches to 1. That is done below.
+    timerValue[TCR] = (timerValue[TCR] & 0xfe);
+    timerValue[TSR] = (timerValue[TSR] | 0x01);
+
+    // Dispatch an IRQ only if user has set this in the
+    // TCR register. (5 and 7) are the only valid
+    // Interupts.
+    if (((cTCR>>5) & 5) || ((cTCR>>5) &7))
+    {
+      InterruptRequest(TIMER_IRQ);
+    }
+    (myCPU.eventHandler()).Add(this, TIMER_EVENT, 0, TIMER_CPU_CYCLE);
+  }
+  else
+  {
+    (myCPU.eventHandler()).Add(this, TIMER_EVENT, 0, TIMER_CPU_CYCLE);
+  }
+}
+
+/*______________________________________________________________
+ | METHOD:  CopyCPRtoCNTR
+ | DESC:	Copies the register value of CPR to CNTR.
+ | USED:	By funce  EventCallback
+ | DEP FUNC: None
+ |______________________________________________________________
+*/
+void Timer::copyCPRtoCNTR()
+{
+  timerValue[CNTRH] = timerValue[CPRH];
+  timerValue[CNTRM] = timerValue[CPRM];
+  timerValue[CNTRL] = timerValue[CPRL];
+}
+
+/*______________________________________________________________
+ | METHOD: decCNTR
+ | DESC: decriments the counter and checks for CNTR==0
+ |		retuns the value of CNTR.
+ |______________________________________________________________
+*/
+unsigned int Timer::decCNTR()
+{
+  int decValue;
+  int temp24;
+
+  // Grab the values of the 24bit register to a value.
+  decValue = 0;
+  temp24 = (unsigned int) timerValue[CNTRH];
+  decValue = (decValue | ( temp24 <<  24));
+
+  temp24 = (unsigned int) timerValue[CNTRM];
+  decValue = (decValue | (temp24 << 16));
+
+  decValue = (decValue | timerValue[CNTRL]);
+
+  decValue -= 250;
+  if(decValue < 0)
+  {
+    decValue = 0;
+  }
+
+  // Put the value  back  the 24bit register to a value.
+  // with the decremnt.
+  timerValue[CNTRH] = ( unsigned char) (decValue >>  24);
+  timerValue[CNTRM] = ( unsigned char) (decValue >> 16);
+  timerValue[CNTRL] = ( unsigned char) (decValue );
+
+  return (unsigned int) decValue;
+}
+
diff -ur bsvc-2.1/src/sim68000/devices/Timer.hxx bsvc-2.1-fixed/src/sim68000/devices/Timer.hxx
--- bsvc-2.1/src/sim68000/devices/Timer.hxx	1998-11-09 04:39:28.000000000 +0100
+++ bsvc-2.1-fixed/src/sim68000/devices/Timer.hxx	2007-05-30 22:47:40.000000000 +0200
@@ -23,11 +23,9 @@
 
 #include <string>
 
-#ifdef USE_STD
-  using namespace std;
-#endif
+using namespace std;
 
-#include "BasicDevice.hxx"
+#include "../../Framework/BasicDevice.hxx"
 
 #define AUTOVECTOR_INTERRUPT  -1
 #define SPURIOUS_INTERRUPT    -2
diff -ur bsvc-2.1/src/sim68000/loader/Loader.cxx bsvc-2.1-fixed/src/sim68000/loader/Loader.cxx
--- bsvc-2.1/src/sim68000/loader/Loader.cxx	1998-11-09 04:39:28.000000000 +0100
+++ bsvc-2.1-fixed/src/sim68000/loader/Loader.cxx	2007-05-30 22:47:40.000000000 +0200
@@ -13,9 +13,9 @@
 // $Id: Loader.cxx,v 1.1 1996/08/06 11:53:58 bwmott Exp $
 ///////////////////////////////////////////////////////////////////////////////
 
-#include "AddressSpace.hxx"
-#include "BasicCPU.hxx"
-#include "Tools.hxx"
+#include "../../Framework/AddressSpace.hxx"
+#include "../../Framework/BasicCPU.hxx"
+#include "../../Framework/Tools.hxx"
 #include "Loader.hxx"
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -26,11 +26,7 @@
   string error;
 
   // Open the file for reading
-  #ifdef USE_STD
-    fstream file(filename, ios::in);
-  #else
-    fstream file(filename, ios::in | ios::nocreate);
-  #endif
+  fstream file(filename, ios::in);
 
   // Make sure the file was opened
   if(file.fail())
diff -ur bsvc-2.1/src/sim68000/loader/Loader.hxx bsvc-2.1-fixed/src/sim68000/loader/Loader.hxx
--- bsvc-2.1/src/sim68000/loader/Loader.hxx	1998-11-09 04:39:28.000000000 +0100
+++ bsvc-2.1-fixed/src/sim68000/loader/Loader.hxx	2007-05-30 22:47:40.000000000 +0200
@@ -16,19 +16,12 @@
 #ifndef LOADER_HXX
 #define LOADER_HXX
 
-#ifdef WIN32
-  #include <iostream>
-  #include <fstream>
-#else
-  #include <iostream.h>
-  #include <fstream.h>
-#endif
+#include <iostream>
+#include <fstream>
 
-#ifdef USE_STD
-  using namespace std;
-#endif
+using namespace std;
 
-#include "BasicLoader.hxx"
+#include "../../Framework/BasicLoader.hxx"
 
 ///////////////////////////////////////////////////////////////////////////////
 // The Loader Class
diff -ur bsvc-2.1/src/sim68000/main.cxx bsvc-2.1-fixed/src/sim68000/main.cxx
--- bsvc-2.1/src/sim68000/main.cxx	1998-11-09 04:39:28.000000000 +0100
+++ bsvc-2.1-fixed/src/sim68000/main.cxx	2007-05-30 22:47:40.000000000 +0200
@@ -14,12 +14,12 @@
 // $Id: main.cxx,v 1.1 1996/08/02 14:58:12 bwmott Exp $
 ///////////////////////////////////////////////////////////////////////////////
 
-#include "Interface.hxx"
+#include "../Framework/Interface.hxx"
 #include "cpu/m68000.hxx"
 #include "devices/DeviceRegistry.hxx"
 #include "loader/Loader.hxx"
 
-main()
+int main()
 {
   BasicCPU& processor = *(new m68000);
   BasicLoader& loader = *(new Loader(processor));
diff -ur bsvc-2.1/src/sim68360/cpu/Makefile bsvc-2.1-fixed/src/sim68360/cpu/Makefile
--- bsvc-2.1/src/sim68360/cpu/Makefile	1998-11-09 04:39:29.000000000 +0100
+++ bsvc-2.1-fixed/src/sim68360/cpu/Makefile	2007-05-30 22:47:40.000000000 +0200
@@ -31,7 +31,7 @@
 	$(CC) $(INCLUDES) -o instruction instruction.c
 
 cpu32DecodeTable.hxx: instruction instruction.list
-	$(PROJECT_BASE)/src/sim68360/cpu/instruction  
+	./instruction  
 
 clean:
 	rm -f *.o $(LIBRARY) instruction
diff -ur bsvc-2.1/src/sim68360/cpu/cpu32.cxx bsvc-2.1-fixed/src/sim68360/cpu/cpu32.cxx
--- bsvc-2.1/src/sim68360/cpu/cpu32.cxx	1998-11-09 04:39:29.000000000 +0100
+++ bsvc-2.1-fixed/src/sim68360/cpu/cpu32.cxx	2007-05-30 22:47:40.000000000 +0200
@@ -24,11 +24,11 @@
 // $Id: m68000.cxx,v 1.1 1996/08/02 14:59:18 bwmott Exp $
 ///////////////////////////////////////////////////////////////////////////////
 
-#include "Tools.hxx"
+#include "../../Framework/Tools.hxx"
 #include "cpu32.hxx"
-#include "BasicDevice.hxx"
-#include "RegInfo.hxx"
-#include "AddressSpace.hxx"
+#include "../../Framework/BasicDevice.hxx"
+#include "../../Framework/RegInfo.hxx"
+#include "../../Framework/AddressSpace.hxx"
 
 // Array of information about each register
 cpu32::RegisterData cpu32::ourRegisterData[] = {
diff -ur bsvc-2.1/src/sim68360/cpu/cpu32.hxx bsvc-2.1-fixed/src/sim68360/cpu/cpu32.hxx
--- bsvc-2.1/src/sim68360/cpu/cpu32.hxx	1998-11-09 04:39:29.000000000 +0100
+++ bsvc-2.1-fixed/src/sim68360/cpu/cpu32.hxx	2007-05-30 22:47:40.000000000 +0200
@@ -27,19 +27,13 @@
 
 #include <string>
 
-#ifdef WIN32
-  #include <iostream>
-#else
-  #include <iostream.h>
-#endif
-
-#ifdef USE_STD
-  using namespace std;
-#endif
+#include <iostream>
+
+using namespace std;
 
 class BasicDevice;
 
-#include "BasicCPU.hxx"
+#include "../../Framework/BasicCPU.hxx"
 
 // Set Condition Code operation types
 #define ADDITION    0
diff -ur bsvc-2.1/src/sim68360/cpu/exec.cxx bsvc-2.1-fixed/src/sim68360/cpu/exec.cxx
--- bsvc-2.1/src/sim68360/cpu/exec.cxx	1998-11-09 04:39:29.000000000 +0100
+++ bsvc-2.1-fixed/src/sim68360/cpu/exec.cxx	2007-05-30 22:47:40.000000000 +0200
@@ -40,13 +40,11 @@
 
 #include <string>
 
-#ifdef USE_STD
-  using namespace std;
-#endif
+using namespace std;
 
-#include "AddressSpace.hxx"
+#include "../../Framework/AddressSpace.hxx"
 #include "cpu32.hxx"
-#include "Tools.hxx"
+#include "../../Framework/Tools.hxx"
 
 ///////////////////////////////////////////////////////////////////////////////
 // Compute the effective address, given the mode and register bits
diff -ur bsvc-2.1/src/sim68360/devices/DeviceRegistry.cxx bsvc-2.1-fixed/src/sim68360/devices/DeviceRegistry.cxx
--- bsvc-2.1/src/sim68360/devices/DeviceRegistry.cxx	1998-11-09 04:39:29.000000000 +0100
+++ bsvc-2.1-fixed/src/sim68360/devices/DeviceRegistry.cxx	2007-05-30 22:47:40.000000000 +0200
@@ -16,24 +16,16 @@
 // $Id: DeviceRegistry.cxx,v 1.1 1996/08/02 15:00:34 bwmott Exp $
 ///////////////////////////////////////////////////////////////////////////////
 
-#ifdef WIN32
-  #include <iostream>
-#else
-  #include <iostream.h>
-#endif
+#include <iostream>
 
-#ifdef USE_STD
-  using namespace std;
-#endif
+using namespace std;
 
 #include "DeviceRegistry.hxx"
 #include "RAM.hxx"
 #include "Timer.hxx"
 
-#ifndef WIN32
-  #include "Gdbsock.hxx"
-  #include "M68681.hxx"
-#endif
+#include "Gdbsock.hxx"
+#include "M68681.hxx"
 
 ///////////////////////////////////////////////////////////////////////////////
 // Array of device information (name, description, tcl script)
diff -ur bsvc-2.1/src/sim68360/devices/DeviceRegistry.hxx bsvc-2.1-fixed/src/sim68360/devices/DeviceRegistry.hxx
--- bsvc-2.1/src/sim68360/devices/DeviceRegistry.hxx	1998-11-09 04:39:29.000000000 +0100
+++ bsvc-2.1-fixed/src/sim68360/devices/DeviceRegistry.hxx	2007-05-30 22:47:40.000000000 +0200
@@ -17,7 +17,7 @@
 #ifndef DEVICEREGISTRY_HXX
 #define DEVICEREGISTRY_HXX
 
-#include "BasicDeviceRegistry.hxx"
+#include "../../Framework/BasicDeviceRegistry.hxx"
 
 ///////////////////////////////////////////////////////////////////////////////
 // The DeviceRegistry Class
diff -ur bsvc-2.1/src/sim68360/devices/Gdbsock.cxx bsvc-2.1-fixed/src/sim68360/devices/Gdbsock.cxx
--- bsvc-2.1/src/sim68360/devices/Gdbsock.cxx	1998-11-09 04:39:29.000000000 +0100
+++ bsvc-2.1-fixed/src/sim68360/devices/Gdbsock.cxx	2007-05-30 22:47:40.000000000 +0200
@@ -29,13 +29,8 @@
 // $Id: $
 ///////////////////////////////////////////////////////////////////////////////
 
-#ifdef WIN32
-#include <iostream.h>
-#include <strstrea.h>
-#else
-#include <iostream.h>
-#include <strstream.h>
-#endif
+#include <iostream>
+#include <strstream>
 
 #include <sys/time.h>
 #include <sys/types.h>
@@ -47,8 +42,8 @@
 #include <stdlib.h>
 #include <errno.h>
 
-#include "Tools.hxx"
-#include "BasicCPU.hxx"
+#include "../../Framework/Tools.hxx"
+#include "../../Framework/BasicCPU.hxx"
 #include "Gdbsock.hxx"
 
 // The duration of the default select events
diff -ur bsvc-2.1/src/sim68360/devices/Gdbsock.hxx bsvc-2.1-fixed/src/sim68360/devices/Gdbsock.hxx
--- bsvc-2.1/src/sim68360/devices/Gdbsock.hxx	1998-11-09 04:39:29.000000000 +0100
+++ bsvc-2.1-fixed/src/sim68360/devices/Gdbsock.hxx	2007-05-30 22:47:40.000000000 +0200
@@ -19,7 +19,7 @@
 #ifndef GDBSOCK_HXX
 #define GDBSOCK_HXX
 
-#include "BasicDevice.hxx"
+#include "../../Framework/BasicDevice.hxx"
 
 class GdbSocket : public BasicDevice {
   public:
diff -ur bsvc-2.1/src/sim68360/devices/M68681.cxx bsvc-2.1-fixed/src/sim68360/devices/M68681.cxx
--- bsvc-2.1/src/sim68360/devices/M68681.cxx	1998-11-09 04:39:29.000000000 +0100
+++ bsvc-2.1-fixed/src/sim68360/devices/M68681.cxx	2007-05-30 22:47:40.000000000 +0200
@@ -13,8 +13,8 @@
 // $Id: M68681.cxx,v 1.1 1996/08/02 15:01:10 bwmott Exp $
 ///////////////////////////////////////////////////////////////////////////////
 
-#include <iostream.h>
-#include <strstream.h>
+#include <iostream>
+#include <strstream>
 #include <string>
 
 #include <sys/types.h>
@@ -22,7 +22,7 @@
 #include <fcntl.h>
 #include <signal.h>
 
-#include "BasicCPU.hxx"
+#include "../../Framework/BasicCPU.hxx"
 #include "M68681.hxx"
 
 // Callback types
diff -ur bsvc-2.1/src/sim68360/devices/M68681.hxx bsvc-2.1-fixed/src/sim68360/devices/M68681.hxx
--- bsvc-2.1/src/sim68360/devices/M68681.hxx	1998-11-09 04:39:29.000000000 +0100
+++ bsvc-2.1-fixed/src/sim68360/devices/M68681.hxx	2007-05-30 22:47:40.000000000 +0200
@@ -19,7 +19,9 @@
 #include <string>
 #include <sys/types.h>
 
-#include "BasicDevice.hxx"
+#include "../../Framework/BasicDevice.hxx"
+
+using namespace std;
 
 class M68681 : public BasicDevice {
   public:
diff -ur bsvc-2.1/src/sim68360/devices/RAM.cxx bsvc-2.1-fixed/src/sim68360/devices/RAM.cxx
--- bsvc-2.1/src/sim68360/devices/RAM.cxx	1998-11-09 04:39:29.000000000 +0100
+++ bsvc-2.1-fixed/src/sim68360/devices/RAM.cxx	2007-05-30 22:47:40.000000000 +0200
@@ -13,20 +13,13 @@
 // $Id: RAM.cxx,v 1.1 1996/08/02 15:02:49 bwmott Exp $
 ///////////////////////////////////////////////////////////////////////////////
 
-#ifdef WIN32
-  #include <iostream>
-  #include <strstream>
-#else
-  #include <iostream.h>
-  #include <strstream.h>
-#endif
-
-#ifdef USE_STD
-  using namespace std;
-#endif
+#include <iostream>
+#include <strstream>
 
-#include "Tools.hxx"
-#include "BasicCPU.hxx"
+using namespace std;
+
+#include "../../Framework/Tools.hxx"
+#include "../../Framework/BasicCPU.hxx"
 #include "RAM.hxx"
 
 ///////////////////////////////////////////////////////////////////////////////
diff -ur bsvc-2.1/src/sim68360/devices/RAM.hxx bsvc-2.1-fixed/src/sim68360/devices/RAM.hxx
--- bsvc-2.1/src/sim68360/devices/RAM.hxx	1998-11-09 04:39:29.000000000 +0100
+++ bsvc-2.1-fixed/src/sim68360/devices/RAM.hxx	2007-05-30 22:47:40.000000000 +0200
@@ -18,11 +18,9 @@
 
 #include <string>
 
-#ifdef USE_STD
-  using namespace std;
-#endif
+using namespace std;
 
-#include "BasicDevice.hxx"
+#include "../../Framework/BasicDevice.hxx"
 
 class RAM : public BasicDevice {
   public:
diff -ur bsvc-2.1/src/sim68360/devices/Timer.cxx bsvc-2.1-fixed/src/sim68360/devices/Timer.cxx
--- bsvc-2.1/src/sim68360/devices/Timer.cxx	1998-11-09 04:39:29.000000000 +0100
+++ bsvc-2.1-fixed/src/sim68360/devices/Timer.cxx	2007-05-30 22:47:40.000000000 +0200
@@ -1,366 +1,358 @@
-///////////////////////////////////////////////////////////////////////////////
-//
-// Timer.cxx
-//
-//   This class keeps up with a list of all of the availible devices and
-// allocates them.  It's dervied from the BasicDeviceRegistry
-//
-// FILENAME: Timer.cxx
-// DESC: Simulates an timer for the M68000 CPU. Thus giving 
-//       the Simulator the ablility to simulate a timmer intrurpt.
-//       Programmers can impliment time slicing with this timmer.
-//
-//       Contains Register and Offsets for the timer. 
-//
-// CREATE:  7-17-98
-// OWNER:   Xavier Plasencia
-// ORG:	    SDSU
-// DEPEN:   This file requiers the Event hander and the BasicDevice files.  
-//
-///////////////////////////////////////////////////////////////////////////////
-// $Id: $
-///////////////////////////////////////////////////////////////////////////////
-
-#ifdef WIN32
-  #include <iostream>
-  #include <strstream>
-  #include <cstring>
-#else
-  #include <iostream.h>
-  #include <strstream.h>
-  #include <string.h>
-#endif
-
-#ifdef USE_STD
-  using namespace std;
-#endif
-
-#include "BasicCPU.hxx"
-#include "Timer.hxx"
-
-///////////////////////////////////////////////////////////////////////////////
-// Constructor
-///////////////////////////////////////////////////////////////////////////////
-Timer::Timer(const string& args, BasicCPU& cpu)
-	: BasicDevice("Timer", args, cpu)
-{
-  istrstream in((char*)args.data(), args.size());
-  string keyword, equals;
-  unsigned long base;
-  unsigned long irq;
-
-  firstTime = true;
-  // Scan "BaseAddress = nnnn"
-  // This is important for the CPU to know what address space
-  // is used by the device.
-  in >> keyword >> equals >> hex >> base;
-  if((!in) || (keyword != "BaseAddress") || (equals != "="))
-  {
-     ErrorMessage("Invalid initialization arguments!");
-     return;
-  }
-
-  in >> keyword >> equals >> hex >> irq;
-  if((!in) || (keyword != "IRQ") || (equals != "="))
-  {
-     ErrorMessage("Invalid initialization arguments!");
-     return;
-  }
-
-/*
-  I've hardcoded the cycles setting to 2000 which should provide the
-  125000 ticks per second for the PI/T
-
-  unsigned long timer_cycle;
-  in >> keyword >> equals >> hex >> timer_cycle;
-  if((!in) || (keyword != "CycleSec") || (equals != "="))
-  {
-     ErrorMessage("Invalid initialization arguments!");
-     return;
-  }
-  Timer::TIMER_CPU_CYCLE = timer_cycle;
-*/
-
-  Timer::TIMER_IRQ = irq;
-  Timer::TIMER_CPU_CYCLE = 2000;
-  baseAddress = base * cpu.Granularity();
-
-  // This is needed to start the whole process.  The eventhandler
-  // will always request an event and test to see if the user has
-  // enabled the timer it not nothing happens but if so. The
-  // CPR  register is copied to the CNTR and is decremented for every
-  // Cycle.
-  (myCPU.eventHandler()).Add(this, TIMER_EVENT, 0, TIMER_CPU_CYCLE);
-
-  Reset(); 
-}
-
-///////////////////////////////////////////////////////////////////////////////
-// This routine should set myInterruptPending flag and send a request
-// to the CPU for an interrupt.
-///////////////////////////////////////////////////////////////////////////////
-void Timer::InterruptRequest(int level)
-{
-  // If no interrupt is pending then request one
-  if(!myInterruptPending)
-  {
-    myInterruptPending = true;
-    myCPU.InterruptRequest(this, level);
-  }
-}
-       
-/*___________________________________________________________________________
- | FUNCTIONAME: InterruptAcknowledge(int)
- | DESC: This routine is called by the CPU when it processes a 
- |  requested interrupt. It should return the vector number associated with 
- |  the interrupt or AUTOVECTOR_INTERRUPT if the device doesn't generate 
- |	vectors.  This default routine only does autovector interrupts.
- | 	This function is called by the CPU.  The return value is usally the
- | 	memory location of a exemption funcion.  How to handel these functions
- |	one shold refer to a Motorla text book.
- | PARAM: None
- | NOTE: Vecotor codes 5 and 7 are the only masks that will make the timer 
- | do somthing.  5 is a VECTOR and 7 is an AUTOVECTOR.  The code
- | can be found in any manual.
- |___________________________________________________________________________
-*/
-long Timer::InterruptAcknowledge(int)
-{
-  unsigned char cTCR = timerValue[TCR];
-
-  if(myInterruptPending)
-  {
-    switch(cTCR>>5)
-    {
-      case 5:
-        //By returning the address of the vector, the cpu will
-        //call the vector that is located in the right mem location.
-        myInterruptPending = false;
-        return timerValue[TIVR];
-        break; 
-
-      case 7:
-        myInterruptPending = false;
-        return AUTOVECTOR_INTERRUPT;
-        break;
-
-      default:
-        return SPURIOUS_INTERRUPT;
-    }
-  }
-  else
-  {
-    return(SPURIOUS_INTERRUPT);
-  }
-}
-
-/*______________________________________________________________
- | METHOD: Timer::CheckMapped( unsigned long adress)
- | DESC: Check to see if address mapps to device. 
- |______________________________________________________________
-*/
-bool Timer::CheckMapped(unsigned long address) const
-{
-  return ((address >= baseAddress ) && 
-      (address <= baseAddress+(22*sizeof(char))));
-}
-
-/*______________________________________________________________
- | METHOD: Timer::Peek(unsigned long address)
- | DESC:  Returns a byte from the device's address.
- |
- |	PEEK is the protocal that is used by the device to 
- |	inform the CPU what the registry settings are.
- |  The use need not update the memory location for the CPU
- |	All of this is done by the cpu and thus uses peek to
- |	read the data that the device is using for the  Memory
- |  (i.e. RAM)
- |______________________________________________________________
-*/
-unsigned char Timer::Peek(unsigned long address)
-{
-  switch((address-baseAddress))
-  {
-    case TCR:
-      return timerValue[TCR];
-    case TIVR:
-      return timerValue[TIVR];
-    case NULR:
-      return timerValue[NULR];
-    case CPRH:
-      return timerValue[CPRH];
-    case CPRM:
-      return timerValue[CPRM];
-    case CPRL:
-      return timerValue[CPRL];
-    case CNTRH:
-      return timerValue[CNTRH];
-    case CNTRM:
-      return timerValue[CNTRM];
-    case CNTRL:
-      return timerValue[CNTRL];
-    case TSR:
-      return timerValue[TSR];
-   }
-   return 0; //Error not a valid address.
-}
-
-/*______________________________________________________________
- | METHOD: Timer::Poke(unsigned long address, char c)
- | DESC:  This is the interface to the rest of the World.  Here
- |	the CPU or anyother devece writes to memory and updates the
- |  device.  Poke Changes the value of the registers.  
- |  Notice that there is no way for the user to WRITE to the 
- |  registers CNTR, this is because they are read only.
- |______________________________________________________________
-*/
-void Timer::Poke(unsigned long address, unsigned char c)
-{
-  switch((address-baseAddress))
-  {
-    case TCR:
-      timerValue[TCR]=c;
-      break;
-    case TIVR:
-      timerValue[TIVR]=c;
-      break;
-    case NULR:
-      timerValue[NULR]=c;
-      break;
-    case CPRH:
-      timerValue[CPRH]=c;
-      break;
-    case CPRM:
-      timerValue[CPRM]=c;
-      break;
-    case CPRL:
-      timerValue[CPRL]=c;
-      break;
-    case TSR:
-      timerValue[TSR]=c;
-      break;
-  }
-}
-
-/*______________________________________________________________
- | METHOD:  Timer::Reset()
- | DESC:	Resets the timer. And Initalizes the Registers.
- |______________________________________________________________
-*/
-void Timer::Reset()
-{
-  // Resets the interupt handler.
-  myInterruptPending = false;
-  firstTime = true;
-
-  // Clears the timers.
-  for(int i=0; i <22; i++)
-    timerValue[i]=0;
-}
-
-/*______________________________________________________________
- | METHOD:	VetcorTimer::EventCallback(long *data, void *ptr)
- | DESC:	Function that executes when interupt occures.
- | DEP FUNC: Requires decCNTR copyCPRtoCNTR.
- |______________________________________________________________
-*/
-void Timer::EventCallback(long data, void *ptr)
-{
-  unsigned char cTCR = timerValue[TCR];
-
-  // Test to see if timer is enabled, if False(0) do nothing.
-  // but dispatch an event.
-  if((cTCR&1) == 1)
-  {
-    // This test to see if the timer has not started a 
-    // count down.  If it hasnt, copy the CPR register vaules
-    // to the CNTR registers.
-    if(firstTime == true)
-    {
-      firstTime = false;
-      copyCPRtoCNTR();
-    }
-
-    // Decriments the CNTR if 0 then call interrupt.
-    // else dispatch an event.
-    if(decCNTR() != 0)
-    {
-      (myCPU.eventHandler()).Add(this, TIMER_EVENT, 0, TIMER_CPU_CYCLE);
-      return;
-    }
-
-    // Since the timer is now done, set the first time to ture,
-    // so the next time the TCR is set to 1 it will copy the
-    // CPR Register to CNTR.
-    firstTime = true;
-
-    // Protocal says that the TCR should flip to 0. and that
-    // TSR bit switches to 1. That is done below.
-    timerValue[TCR] = (timerValue[TCR] & 0xfe);
-    timerValue[TSR] = (timerValue[TSR] | 0x01);
-
-    // Dispatch an IRQ only if user has set this in the
-    // TCR register. (5 and 7) are the only valid
-    // Interupts.
-    if (((cTCR>>5) & 5) || ((cTCR>>5) &7))
-    {
-      InterruptRequest(TIMER_IRQ);
-    }
-    (myCPU.eventHandler()).Add(this, TIMER_EVENT, 0, TIMER_CPU_CYCLE);
-  }
-  else
-  {
-    (myCPU.eventHandler()).Add(this, TIMER_EVENT, 0, TIMER_CPU_CYCLE);
-  }
-}
-
-/*______________________________________________________________
- | METHOD:  CopyCPRtoCNTR
- | DESC:	Copies the register value of CPR to CNTR.
- | USED:	By funce  EventCallback
- | DEP FUNC: None
- |______________________________________________________________
-*/
-void Timer::copyCPRtoCNTR()
-{
-  timerValue[CNTRH] = timerValue[CPRH];
-  timerValue[CNTRM] = timerValue[CPRM];
-  timerValue[CNTRL] = timerValue[CPRL];
-}
-
-/*______________________________________________________________
- | METHOD: decCNTR
- | DESC: decriments the counter and checks for CNTR==0
- |		retuns the value of CNTR.
- |______________________________________________________________
-*/
-unsigned int Timer::decCNTR()
-{
-  int decValue;
-  int temp24;
-
-  // Grab the values of the 24bit register to a value.
-  decValue = 0;
-  temp24 = (unsigned int) timerValue[CNTRH];
-  decValue = (decValue | ( temp24 <<  24));
-
-  temp24 = (unsigned int) timerValue[CNTRM];
-  decValue = (decValue | (temp24 << 16));
-
-  decValue = (decValue | timerValue[CNTRL]);
-
-  decValue -= 250;
-  if(decValue < 0)
-  {
-    decValue = 0;
-  }
-
-  // Put the value  back  the 24bit register to a value.
-  // with the decremnt.
-  timerValue[CNTRH] = ( unsigned char) (decValue >>  24);
-  timerValue[CNTRM] = ( unsigned char) (decValue >> 16);
-  timerValue[CNTRL] = ( unsigned char) (decValue );
-
-  return (unsigned int) decValue;
-}
-
+///////////////////////////////////////////////////////////////////////////////
+//
+// Timer.cxx
+//
+//   This class keeps up with a list of all of the availible devices and
+// allocates them.  It's dervied from the BasicDeviceRegistry
+//
+// FILENAME: Timer.cxx
+// DESC: Simulates an timer for the M68000 CPU. Thus giving 
+//       the Simulator the ablility to simulate a timmer intrurpt.
+//       Programmers can impliment time slicing with this timmer.
+//
+//       Contains Register and Offsets for the timer. 
+//
+// CREATE:  7-17-98
+// OWNER:   Xavier Plasencia
+// ORG:	    SDSU
+// DEPEN:   This file requiers the Event hander and the BasicDevice files.  
+//
+///////////////////////////////////////////////////////////////////////////////
+// $Id: $
+///////////////////////////////////////////////////////////////////////////////
+
+#include <iostream>
+#include <strstream>
+#include <string>
+
+using namespace std;
+
+#include "../../Framework/BasicCPU.hxx"
+#include "Timer.hxx"
+
+///////////////////////////////////////////////////////////////////////////////
+// Constructor
+///////////////////////////////////////////////////////////////////////////////
+Timer::Timer(const string& args, BasicCPU& cpu)
+	: BasicDevice("Timer", args, cpu)
+{
+  istrstream in((char*)args.data(), args.size());
+  string keyword, equals;
+  unsigned long base;
+  unsigned long irq;
+
+  firstTime = true;
+  // Scan "BaseAddress = nnnn"
+  // This is important for the CPU to know what address space
+  // is used by the device.
+  in >> keyword >> equals >> hex >> base;
+  if((!in) || (keyword != "BaseAddress") || (equals != "="))
+  {
+     ErrorMessage("Invalid initialization arguments!");
+     return;
+  }
+
+  in >> keyword >> equals >> hex >> irq;
+  if((!in) || (keyword != "IRQ") || (equals != "="))
+  {
+     ErrorMessage("Invalid initialization arguments!");
+     return;
+  }
+
+/*
+  I've hardcoded the cycles setting to 2000 which should provide the
+  125000 ticks per second for the PI/T
+
+  unsigned long timer_cycle;
+  in >> keyword >> equals >> hex >> timer_cycle;
+  if((!in) || (keyword != "CycleSec") || (equals != "="))
+  {
+     ErrorMessage("Invalid initialization arguments!");
+     return;
+  }
+  Timer::TIMER_CPU_CYCLE = timer_cycle;
+*/
+
+  Timer::TIMER_IRQ = irq;
+  Timer::TIMER_CPU_CYCLE = 2000;
+  baseAddress = base * cpu.Granularity();
+
+  // This is needed to start the whole process.  The eventhandler
+  // will always request an event and test to see if the user has
+  // enabled the timer it not nothing happens but if so. The
+  // CPR  register is copied to the CNTR and is decremented for every
+  // Cycle.
+  (myCPU.eventHandler()).Add(this, TIMER_EVENT, 0, TIMER_CPU_CYCLE);
+
+  Reset(); 
+}
+
+///////////////////////////////////////////////////////////////////////////////
+// This routine should set myInterruptPending flag and send a request
+// to the CPU for an interrupt.
+///////////////////////////////////////////////////////////////////////////////
+void Timer::InterruptRequest(int level)
+{
+  // If no interrupt is pending then request one
+  if(!myInterruptPending)
+  {
+    myInterruptPending = true;
+    myCPU.InterruptRequest(this, level);
+  }
+}
+       
+/*___________________________________________________________________________
+ | FUNCTIONAME: InterruptAcknowledge(int)
+ | DESC: This routine is called by the CPU when it processes a 
+ |  requested interrupt. It should return the vector number associated with 
+ |  the interrupt or AUTOVECTOR_INTERRUPT if the device doesn't generate 
+ |	vectors.  This default routine only does autovector interrupts.
+ | 	This function is called by the CPU.  The return value is usally the
+ | 	memory location of a exemption funcion.  How to handel these functions
+ |	one shold refer to a Motorla text book.
+ | PARAM: None
+ | NOTE: Vecotor codes 5 and 7 are the only masks that will make the timer 
+ | do somthing.  5 is a VECTOR and 7 is an AUTOVECTOR.  The code
+ | can be found in any manual.
+ |___________________________________________________________________________
+*/
+long Timer::InterruptAcknowledge(int)
+{
+  unsigned char cTCR = timerValue[TCR];
+
+  if(myInterruptPending)
+  {
+    switch(cTCR>>5)
+    {
+      case 5:
+        //By returning the address of the vector, the cpu will
+        //call the vector that is located in the right mem location.
+        myInterruptPending = false;
+        return timerValue[TIVR];
+        break; 
+
+      case 7:
+        myInterruptPending = false;
+        return AUTOVECTOR_INTERRUPT;
+        break;
+
+      default:
+        return SPURIOUS_INTERRUPT;
+    }
+  }
+  else
+  {
+    return(SPURIOUS_INTERRUPT);
+  }
+}
+
+/*______________________________________________________________
+ | METHOD: Timer::CheckMapped( unsigned long adress)
+ | DESC: Check to see if address mapps to device. 
+ |______________________________________________________________
+*/
+bool Timer::CheckMapped(unsigned long address) const
+{
+  return ((address >= baseAddress ) && 
+      (address <= baseAddress+(22*sizeof(char))));
+}
+
+/*______________________________________________________________
+ | METHOD: Timer::Peek(unsigned long address)
+ | DESC:  Returns a byte from the device's address.
+ |
+ |	PEEK is the protocal that is used by the device to 
+ |	inform the CPU what the registry settings are.
+ |  The use need not update the memory location for the CPU
+ |	All of this is done by the cpu and thus uses peek to
+ |	read the data that the device is using for the  Memory
+ |  (i.e. RAM)
+ |______________________________________________________________
+*/
+unsigned char Timer::Peek(unsigned long address)
+{
+  switch((address-baseAddress))
+  {
+    case TCR:
+      return timerValue[TCR];
+    case TIVR:
+      return timerValue[TIVR];
+    case NULR:
+      return timerValue[NULR];
+    case CPRH:
+      return timerValue[CPRH];
+    case CPRM:
+      return timerValue[CPRM];
+    case CPRL:
+      return timerValue[CPRL];
+    case CNTRH:
+      return timerValue[CNTRH];
+    case CNTRM:
+      return timerValue[CNTRM];
+    case CNTRL:
+      return timerValue[CNTRL];
+    case TSR:
+      return timerValue[TSR];
+   }
+   return 0; //Error not a valid address.
+}
+
+/*______________________________________________________________
+ | METHOD: Timer::Poke(unsigned long address, char c)
+ | DESC:  This is the interface to the rest of the World.  Here
+ |	the CPU or anyother devece writes to memory and updates the
+ |  device.  Poke Changes the value of the registers.  
+ |  Notice that there is no way for the user to WRITE to the 
+ |  registers CNTR, this is because they are read only.
+ |______________________________________________________________
+*/
+void Timer::Poke(unsigned long address, unsigned char c)
+{
+  switch((address-baseAddress))
+  {
+    case TCR:
+      timerValue[TCR]=c;
+      break;
+    case TIVR:
+      timerValue[TIVR]=c;
+      break;
+    case NULR:
+      timerValue[NULR]=c;
+      break;
+    case CPRH:
+      timerValue[CPRH]=c;
+      break;
+    case CPRM:
+      timerValue[CPRM]=c;
+      break;
+    case CPRL:
+      timerValue[CPRL]=c;
+      break;
+    case TSR:
+      timerValue[TSR]=c;
+      break;
+  }
+}
+
+/*______________________________________________________________
+ | METHOD:  Timer::Reset()
+ | DESC:	Resets the timer. And Initalizes the Registers.
+ |______________________________________________________________
+*/
+void Timer::Reset()
+{
+  // Resets the interupt handler.
+  myInterruptPending = false;
+  firstTime = true;
+
+  // Clears the timers.
+  for(int i=0; i <22; i++)
+    timerValue[i]=0;
+}
+
+/*______________________________________________________________
+ | METHOD:	VetcorTimer::EventCallback(long *data, void *ptr)
+ | DESC:	Function that executes when interupt occures.
+ | DEP FUNC: Requires decCNTR copyCPRtoCNTR.
+ |______________________________________________________________
+*/
+void Timer::EventCallback(long data, void *ptr)
+{
+  unsigned char cTCR = timerValue[TCR];
+
+  // Test to see if timer is enabled, if False(0) do nothing.
+  // but dispatch an event.
+  if((cTCR&1) == 1)
+  {
+    // This test to see if the timer has not started a 
+    // count down.  If it hasnt, copy the CPR register vaules
+    // to the CNTR registers.
+    if(firstTime == true)
+    {
+      firstTime = false;
+      copyCPRtoCNTR();
+    }
+
+    // Decriments the CNTR if 0 then call interrupt.
+    // else dispatch an event.
+    if(decCNTR() != 0)
+    {
+      (myCPU.eventHandler()).Add(this, TIMER_EVENT, 0, TIMER_CPU_CYCLE);
+      return;
+    }
+
+    // Since the timer is now done, set the first time to ture,
+    // so the next time the TCR is set to 1 it will copy the
+    // CPR Register to CNTR.
+    firstTime = true;
+
+    // Protocal says that the TCR should flip to 0. and that
+    // TSR bit switches to 1. That is done below.
+    timerValue[TCR] = (timerValue[TCR] & 0xfe);
+    timerValue[TSR] = (timerValue[TSR] | 0x01);
+
+    // Dispatch an IRQ only if user has set this in the
+    // TCR register. (5 and 7) are the only valid
+    // Interupts.
+    if (((cTCR>>5) & 5) || ((cTCR>>5) &7))
+    {
+      InterruptRequest(TIMER_IRQ);
+    }
+    (myCPU.eventHandler()).Add(this, TIMER_EVENT, 0, TIMER_CPU_CYCLE);
+  }
+  else
+  {
+    (myCPU.eventHandler()).Add(this, TIMER_EVENT, 0, TIMER_CPU_CYCLE);
+  }
+}
+
+/*______________________________________________________________
+ | METHOD:  CopyCPRtoCNTR
+ | DESC:	Copies the register value of CPR to CNTR.
+ | USED:	By funce  EventCallback
+ | DEP FUNC: None
+ |______________________________________________________________
+*/
+void Timer::copyCPRtoCNTR()
+{
+  timerValue[CNTRH] = timerValue[CPRH];
+  timerValue[CNTRM] = timerValue[CPRM];
+  timerValue[CNTRL] = timerValue[CPRL];
+}
+
+/*______________________________________________________________
+ | METHOD: decCNTR
+ | DESC: decriments the counter and checks for CNTR==0
+ |		retuns the value of CNTR.
+ |______________________________________________________________
+*/
+unsigned int Timer::decCNTR()
+{
+  int decValue;
+  int temp24;
+
+  // Grab the values of the 24bit register to a value.
+  decValue = 0;
+  temp24 = (unsigned int) timerValue[CNTRH];
+  decValue = (decValue | ( temp24 <<  24));
+
+  temp24 = (unsigned int) timerValue[CNTRM];
+  decValue = (decValue | (temp24 << 16));
+
+  decValue = (decValue | timerValue[CNTRL]);
+
+  decValue -= 250;
+  if(decValue < 0)
+  {
+    decValue = 0;
+  }
+
+  // Put the value  back  the 24bit register to a value.
+  // with the decremnt.
+  timerValue[CNTRH] = ( unsigned char) (decValue >>  24);
+  timerValue[CNTRM] = ( unsigned char) (decValue >> 16);
+  timerValue[CNTRL] = ( unsigned char) (decValue );
+
+  return (unsigned int) decValue;
+}
+
diff -ur bsvc-2.1/src/sim68360/devices/Timer.hxx bsvc-2.1-fixed/src/sim68360/devices/Timer.hxx
--- bsvc-2.1/src/sim68360/devices/Timer.hxx	1998-11-09 04:39:29.000000000 +0100
+++ bsvc-2.1-fixed/src/sim68360/devices/Timer.hxx	2007-05-30 22:47:40.000000000 +0200
@@ -23,11 +23,9 @@
 
 #include <string>
 
-#ifdef USE_STD
-  using namespace std;
-#endif
+using namespace std;
 
-#include "BasicDevice.hxx"
+#include "../../Framework/BasicDevice.hxx"
 
 #define AUTOVECTOR_INTERRUPT  -1
 #define SPURIOUS_INTERRUPT    -2
diff -ur bsvc-2.1/src/sim68360/loader/Loader.cxx bsvc-2.1-fixed/src/sim68360/loader/Loader.cxx
--- bsvc-2.1/src/sim68360/loader/Loader.cxx	1998-11-09 04:39:29.000000000 +0100
+++ bsvc-2.1-fixed/src/sim68360/loader/Loader.cxx	2007-05-30 22:47:40.000000000 +0200
@@ -13,9 +13,9 @@
 // $Id: Loader.cxx,v 1.1 1996/08/06 11:53:58 bwmott Exp $
 ///////////////////////////////////////////////////////////////////////////////
 
-#include "AddressSpace.hxx"
-#include "BasicCPU.hxx"
-#include "Tools.hxx"
+#include "../../Framework/AddressSpace.hxx"
+#include "../../Framework/BasicCPU.hxx"
+#include "../../Framework/Tools.hxx"
 #include "Loader.hxx"
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -26,11 +26,7 @@
   string error;
 
   // Open the file for reading
-  #ifdef WIN32
-    fstream file(filename, ios::in);
-  #else
-    fstream file(filename, ios::in | ios::nocreate);
-  #endif
+  fstream file(filename, ios::in);
 
   // Make sure the file was opened
   if(file.fail())
diff -ur bsvc-2.1/src/sim68360/loader/Loader.hxx bsvc-2.1-fixed/src/sim68360/loader/Loader.hxx
--- bsvc-2.1/src/sim68360/loader/Loader.hxx	1998-11-09 04:39:29.000000000 +0100
+++ bsvc-2.1-fixed/src/sim68360/loader/Loader.hxx	2007-05-30 22:47:40.000000000 +0200
@@ -16,19 +16,12 @@
 #ifndef LOADER_HXX
 #define LOADER_HXX
 
-#ifdef WIN32
-  #include <iostream>
-  #include <fstream>
-#else
-  #include <iostream.h>
-  #include <fstream.h>
-#endif
+#include <iostream>
+#include <fstream>
 
-#ifdef USE_STD
-  using namespace std;
-#endif
+using namespace std;
 
-#include "BasicLoader.hxx"
+#include "../../Framework/BasicLoader.hxx"
 
 ///////////////////////////////////////////////////////////////////////////////
 // The Loader Class
diff -ur bsvc-2.1/src/sim68360/main.cxx bsvc-2.1-fixed/src/sim68360/main.cxx
--- bsvc-2.1/src/sim68360/main.cxx	1998-11-09 04:39:29.000000000 +0100
+++ bsvc-2.1-fixed/src/sim68360/main.cxx	2007-05-30 22:47:40.000000000 +0200
@@ -17,12 +17,12 @@
 // $Id: main.cxx,v 1.1 1996/08/02 14:58:12 bwmott Exp $
 ///////////////////////////////////////////////////////////////////////////////
 
-#include "Interface.hxx"
+#include "../Framework/Interface.hxx"
 #include "cpu/cpu32.hxx"
 #include "devices/DeviceRegistry.hxx"
 #include "loader/Loader.hxx"
 
-main()
+int main()
 {
   BasicCPU& processor = *(new cpu32);
   BasicLoader& loader = *(new Loader(processor));
